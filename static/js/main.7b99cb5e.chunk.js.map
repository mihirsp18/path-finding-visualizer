{"version":3,"sources":["maze/recursiveDivision.js","maze/verticalMaze.js","maze/horizontalMaze.js","PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/Astar.js","algorithms/greedyBestFirstSearch.js","algorithms/bidirectionalGreedySearch.js","PathfindingVisualizer/PathfindingVisualizer.jsx","maze/randomMaze.js","App.js","reportWebVitals.js","index.js"],"names":["walls","Node","props","state","this","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","isWeight","extraClassName","id","className","draggable","Component","dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","weight","previousNode","heruistic","a","b","Math","abs","getNeighbours","neighbours","neighbour","manhattenDistance","finishNode","neighbourNotInUnvisitedNodes","isNeighbour","closestNodeStart","closestNodeFinish","rowStart","colStart","rowFinish","colFinish","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","floor","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","verticalMaze","choice","getVerticalWalls","horizontalMaze","getHorizontalWalls","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","row_max_length","col_max_length","PathfindingVisualizer","animateMaze","setTimeout","ClearWalls","newGrid","getNewGridWithMaze","setState","constructingMaze","mazeSpeed","document","getElementById","weightChangeHandler","event","target","value","pointChangeHandler","notCorrect","parseInt","isNaN","toggleWeight","changeWeight","mouseIsPressed","topMessage","distanceToBeTraveled","setStart","setEnd","algo","generatingMaze","speed","win","window","doc","docElem","documentElement","body","getElementsByTagName","x","innerWidth","clientWidth","y","innerHeight","clientHeight","round","console","log","getInitialGrid","getNewGridWithWeightToggled","getNewGridWithWallToggled","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animatePath","openSet","closedset","path","leastIndex","f","current","previous","elt","diagonals","ret","includes","tempG","g","newPath","h","error","astar","totalDistance","greedyBFS","getNodesInShortestPathOrderGreedyBFS","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesFinish","visitedNodesInOrderFinish","bidirectionalGreedySearch","isShortedPath","getNodesInShortestPathOrderBidirectionalGreedySearch","animateBidirectionalAlgorithm","visualizeAstar","visualizeDijkstra","visualizeGreedyBFS","visualizeBidirectionalGreedySearch","animateShortestPath","getVisitedNodesInOrder","undefined","randomMaze","button_task","onClick","setAlgoAstar","setAlgoDijkstra","setAlgoGreedyBFS","setAlgoBiGreedy","visualize","style","width","margin","href","location","reload","changeWeightText","heading","textBox","htmlFor","type","name","min","onChange","defaultValue","generateRandomMaze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","borderSpacing","map","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","n","currentRow","createNode","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.7b99cb5e.chunk.js","sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}\n","let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const {\n      row,\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      isWeight,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isWeight\n      ? \"node-weight\"\n      : \"empty\";\n\n    return (\n      <td\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n        draggable= {isStart || isFinish}\n      ></td> // It is used to create the grid.\n    );\n  }\n}\n","export function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = []; \r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n\r\n    if (closestNode.isWall) continue;\r\n\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === endNode) return visitedNodesInOrder;\r\n\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n\r\n    neighbor.distance = node.distance + neighbor.weight + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function astar(grid, startNode, endNode) {\r\n  let openSet = [];\r\n  let closedset = [];\r\n  let path = [];\r\n  let visitedNodesInOrder = [];\r\n\r\n  openSet.push(startNode);\r\n  while (openSet.length > 0) {\r\n    let leastIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[leastIndex].f) {\r\n        leastIndex = i;\r\n      }\r\n    }\r\n    let current = openSet[leastIndex];\r\n    visitedNodesInOrder.push(current);\r\n\r\n    if (current === endNode) {\r\n      let temp = current;\r\n      path.push(temp);\r\n      while(temp.previous){\r\n        path.push(temp.previous);\r\n        temp = temp.previous\r\n      }\r\n      console.log(path);\r\n      return {path, visitedNodesInOrder};\r\n    }\r\n    openSet = openSet.filter((elt) => elt !== current);\r\n    closedset.push(current);\r\n\r\n    let neighbours = neighbors(grid, current);\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      let neighbour = neighbours[i];\r\n      if (!closedset.includes(neighbour) && !neighbour.isWall) {\r\n        let tempG;\r\n        tempG = current.g + current.weight + 1;\r\n        let newPath = false;\r\n        if(openSet.includes(neighbour)){\r\n          if(tempG < neighbour.g){\r\n            neighbour.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else{\r\n          neighbour.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbour);\r\n        }\r\n\r\n        if(newPath){\r\n          neighbour.h = heruistic(neighbour, endNode);\r\n          neighbour.f = neighbour.g + neighbour.h;\r\n          neighbour.previous = current;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return {path, visitedNodesInOrder, error: \"No Path Found!\"}\r\n}\r\nfunction heruistic(a, b) {\r\n  let d = Math.abs(a.row - b.row) + Math.abs(a.col- b.col);\r\n  return d\r\n}\r\n\r\nfunction neighbors(grid, node, diagonals) {\r\n        var ret = [];\r\n        var x = node.row;\r\n        var y = node.col;\r\n        // West\r\n        if(grid[x-1] && grid[x-1][y]) {\r\n            ret.push(grid[x-1][y]);\r\n        }\r\n\r\n        // East\r\n        if(grid[x+1] && grid[x+1][y]) {\r\n            ret.push(grid[x+1][y]);\r\n        }\r\n\r\n        // South\r\n        if(grid[x] && grid[x][y-1]) {\r\n            ret.push(grid[x][y-1]);\r\n        }\r\n\r\n        // North\r\n        if(grid[x] && grid[x][y+1]) {\r\n            ret.push(grid[x][y+1]);\r\n        }\r\n        return ret;\r\n    }\r\n","export function greedyBFS(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function bidirectionalGreedySearch(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodesStart = [];\r\n  let visitedNodesInOrderStart = [];\r\n  let unvisitedNodesFinish = [];\r\n  let visitedNodesInOrderFinish = [];\r\n  startNode.distance = 0;\r\n  finishNode.distance = 0;\r\n  unvisitedNodesStart.push(startNode);\r\n  unvisitedNodesFinish.push(finishNode);\r\n\r\n  while (\r\n    unvisitedNodesStart.length !== 0 &&\r\n    unvisitedNodesFinish.length !== 0\r\n  ) {\r\n    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNodeStart = unvisitedNodesStart.shift();\r\n    let closestNodeFinish = unvisitedNodesFinish.shift();\r\n\r\n    closestNodeStart.isVisited = true;\r\n    closestNodeFinish.isVisited = true;\r\n    visitedNodesInOrderStart.push(closestNodeStart);\r\n    visitedNodesInOrderFinish.push(closestNodeFinish);\r\n    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\r\n      return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n    }\r\n\r\n    //Start side search\r\n    let neighbours = getNeighbours(closestNodeStart, grid);\r\n    for (let neighbour of neighbours) {\r\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n        visitedNodesInOrderStart.push(closestNodeStart);\r\n        visitedNodesInOrderFinish.push(neighbour);\r\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n      }\r\n      let distance = closestNodeStart.distance + 1;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n        unvisitedNodesStart.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNodeStart;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNodeStart;\r\n      }\r\n    }\r\n\r\n    //Finish side search\r\n    neighbours = getNeighbours(closestNodeFinish, grid);\r\n    for (let neighbour of neighbours) {\r\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n        visitedNodesInOrderStart.push(closestNodeFinish);\r\n        visitedNodesInOrderStart.push(neighbour);\r\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n      }\r\n      let distance = closestNodeFinish.distance + 1;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n        unvisitedNodesFinish.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\r\n        neighbour.previousNode = closestNodeFinish;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode);\r\n        neighbour.previousNode = closestNodeFinish;\r\n      }\r\n    }\r\n  }\r\n  return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\r\n}\r\n\r\nfunction isNeighbour(closestNodeStart, closestNodeFinish) {\r\n  let rowStart = closestNodeStart.row;\r\n  let colStart = closestNodeStart.col;\r\n  let rowFinish = closestNodeFinish.row;\r\n  let colFinish = closestNodeFinish.col;\r\n  if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\r\n  if (rowFinish === rowStart && colFinish === colStart + 1) return true;\r\n  if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\r\n  if (rowFinish === rowStart && colFinish === colStart - 1) return true;\r\n  return false;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction manhattenDistance(nodeA, nodeB) {\r\n  let x = Math.abs(nodeA.row - nodeB.row);\r\n  let y = Math.abs(nodeA.col - nodeB.col);\r\n  return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\r\n  nodeA,\r\n  nodeB\r\n) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = nodeB;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  currentNode = nodeA;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, {\r\n  Component\r\n} from \"react\";\r\n\r\nimport Node from \"./Node/Node.jsx\";\r\n// import {showPopUp} from \"./Tutorial/Tutorial.jsx\";\r\n\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder\r\n} from \"../algorithms/dijkstra\";\r\nimport {\r\n  astar\r\n} from \"../algorithms/Astar.js\";\r\nimport {\r\n  greedyBFS,\r\n  getNodesInShortestPathOrderGreedyBFS,\r\n} from \"../algorithms/greedyBestFirstSearch\";\r\nimport {\r\n  bidirectionalGreedySearch,\r\n  getNodesInShortestPathOrderBidirectionalGreedySearch,\r\n} from \"../algorithms/bidirectionalGreedySearch\";\r\nimport {\r\n  randomMaze\r\n} from \"../maze/randomMaze.js\";\r\nimport {\r\n  recursiveDivisionMaze\r\n} from \"../maze/recursiveDivision.js\";\r\nimport {\r\n  verticalMaze\r\n} from \"../maze/verticalMaze.js\";\r\nimport {\r\n  horizontalMaze\r\n} from \"../maze/horizontalMaze.js\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\n// Defining initial state of start and finish.\r\n\r\nlet row_max_length = 26;\r\nlet col_max_length = 46;\r\n\r\nlet START_NODE_ROW;\r\nlet START_NODE_COL;\r\nlet FINISH_NODE_ROW;\r\nlet FINISH_NODE_COL;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      topMessage: \"Starting\",\r\n      weight: 1,\r\n      changeWeight: false,\r\n      distanceToBeTraveled: 0,\r\n      setStart: false,\r\n      setEnd: false,\r\n      algo: 0,\r\n      generatingMaze: false,\r\n      speed: 10,\r\n      mazeSpeed: 10,\r\n      constructingMaze: false,\r\n    };\r\n  }\r\n\r\n  // Creating grid\r\n  componentDidMount() {\r\n    var win = window,\r\n      doc = document,\r\n      docElem = doc.documentElement,\r\n      body = doc.getElementsByTagName('body')[0],\r\n      x = win.innerWidth || docElem.clientWidth || body.clientWidth,\r\n      y = win.innerHeight || docElem.clientHeight || body.clientHeight;\r\n    row_max_length = (y / 25) / 1.4;\r\n    col_max_length = x / 25;\r\n    START_NODE_ROW = Math.round(row_max_length / 2) - 2;\r\n    START_NODE_COL = 6;\r\n    FINISH_NODE_ROW = Math.round(row_max_length / 2) - 2;\r\n    FINISH_NODE_COL = Math.round(col_max_length - 6);\r\n    console.log(FINISH_NODE_COL);\r\n\r\n\r\n    const grid = getInitialGrid();\r\n    this.setState({\r\n      grid\r\n    });\r\n  }\r\n\r\n  ClearWalls() {\r\n    const grid = getInitialGrid();\r\n    this.setState({\r\n      grid\r\n    });\r\n  }\r\n\r\n\r\n  // On pressing the mouse down\r\n  handleMouseDown(row, col) {\r\n    if (this.state.topMessage !== \"Starting\") return;\r\n    if (!(this.setStart || this.setEnd)) {\r\n      let newGrid = [];\r\n\r\n      if (this.state.changeWeight) {\r\n        newGrid = getNewGridWithWeightToggled(\r\n          this.state.grid,\r\n          row,\r\n          col,\r\n          this.state.weight\r\n        );\r\n      } else {\r\n        newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n      }\r\n\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true\r\n      });\r\n    } else if (this.setStart) {\r\n\r\n    } else if (this.setEnd) {\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // On entering the new node element.\r\n  handleMouseEnter(row, col) {\r\n    if (this.state.topMessage !== \"Starting\") return;\r\n    if (this.setStart || this.setEnd) return;\r\n    if (!this.state.mouseIsPressed) return;\r\n\r\n    let newGrid = [];\r\n\r\n    if (this.state.changeWeight) {\r\n      newGrid = getNewGridWithWeightToggled(\r\n        this.state.grid,\r\n        row,\r\n        col,\r\n        this.state.weight\r\n      );\r\n    } else {\r\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    }\r\n\r\n    this.setState({\r\n      grid: newGrid,\r\n      mouseIsPressed: true\r\n    });\r\n  }\r\n\r\n  // When we release the mouse\r\n  handleMouseUp() {\r\n    if (this.state.topMessage !== \"Starting\") return;\r\n    this.setState({\r\n      mouseIsPressed: false\r\n    });\r\n  }\r\n\r\n  setAlgoAstar() {\r\n    this.setState({\r\n      algo: 1\r\n    });\r\n  }\r\n  setAlgoDijkstra() {\r\n    this.setState({\r\n      algo: 2\r\n    });\r\n  }\r\n  setAlgoGreedyBFS() {\r\n    this.setState({\r\n      algo: 3\r\n    });\r\n  }\r\n  setAlgoBiGreedy() {\r\n    this.setState({\r\n      algo: 4\r\n    });\r\n  }\r\n\r\n\r\n\r\n  visualizeDijkstra() {\r\n    this.setState({\r\n      topMessage: \"Calculating Shortest Path\"\r\n    });\r\n    const {\r\n      grid\r\n    } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeAstar() {\r\n    this.setState({\r\n      topMessage: \"Calculating Shortest Path\"\r\n    });\r\n    const {\r\n      grid\r\n    } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const temp = astar(grid, startNode, finishNode);\r\n    const visitedNodesInOrder = temp.visitedNodesInOrder;\r\n    const nodesInShortestPathOrder = temp.path;\r\n    this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeGreedyBFS() {\r\n    this.setState({\r\n      topMessage: \"Calculating Shortest Path\"\r\n    });\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderGreedyBFS(\r\n        finishNode\r\n      );\r\n      this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBidirectionalGreedySearch() {\r\n    this.setState({\r\n      topMessage: \"Calculating Shortest Path\"\r\n    });\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = bidirectionalGreedySearch(\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    const visitedNodesInOrderStart = visitedNodesInOrder[0];\r\n    const visitedNodesInOrderFinish = visitedNodesInOrder[1];\r\n    const isShortedPath = visitedNodesInOrder[2];\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(\r\n      visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\r\n      visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\r\n    );\r\n    this.animateBidirectionalAlgorithm(\r\n      visitedNodesInOrderStart,\r\n      visitedNodesInOrderFinish,\r\n      nodesInShortestPathOrder,\r\n      isShortedPath\r\n    );\r\n}\r\n\r\n  visualize() {\r\n    if(!this.state.constructingMaze){\r\n      if (this.state.algo === 1) {\r\n        this.visualizeAstar();\r\n      } else if (this.state.algo === 2) {\r\n        this.visualizeDijkstra();\r\n      } else if (this.state.algo === 3) {\r\n        this.visualizeGreedyBFS();\r\n      } else if (this.state.algo === 4) {\r\n        this.visualizeBidirectionalGreedySearch();\r\n      }\r\n    }\r\n  }\r\n\r\n  animatePath(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      // When we reach the last element in visitedNodesInOrder.\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.setState({\r\n            topMessage: \"Shortest Path\"\r\n          });\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, this.state.speed * i);\r\n        return;\r\n      }\r\n\r\n      if (i === visitedNodesInOrder.length - 1) continue;\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (node.isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visitedWeight\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, this.state.speed * i);\r\n    }\r\n  }\r\n  animateBidirectionalAlgorithm(\r\n  visitedNodesInOrderStart,\r\n  visitedNodesInOrderFinish,\r\n  nodesInShortestPathOrder,\r\n  isShortedPath\r\n) {\r\n  let len = Math.max(\r\n    visitedNodesInOrderStart.length,\r\n    visitedNodesInOrderFinish.length\r\n  );\r\n  for (let i = 1; i <= len; i++) {\r\n    let nodeA = visitedNodesInOrderStart[i];\r\n    let nodeB = visitedNodesInOrderFinish[i];\r\n    if (i === visitedNodesInOrderStart.length) {\r\n      setTimeout(() => {\r\n        let visitedNodesInOrder = getVisitedNodesInOrder(\r\n          visitedNodesInOrderStart,\r\n          visitedNodesInOrderFinish\r\n        );\r\n        if (isShortedPath) {\r\n          this.setState({\r\n            topMessage: \"Shortest Path\"\r\n          });\r\n          this.animateShortestPath(\r\n            nodesInShortestPathOrder,\r\n            visitedNodesInOrder\r\n          );\r\n        }\r\n      }, i * this.state.speed);\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      //visited nodes\r\n      if (nodeA !== undefined)\r\n        document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className =\r\n          \"node node-visited\";\r\n      if (nodeB !== undefined)\r\n        document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className =\r\n          \"node node-visited\";\r\n    }, i * this.state.speed);\r\n  }\r\n}\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    let timeTaken = 0;\r\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if (nodesInShortestPathOrder[i].isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path-weight\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path\";\r\n        }\r\n      }, this.state.speed * 5 * i);\r\n    }\r\n    this.setState({\r\n      algo: -1\r\n    });\r\n  }\r\n\r\n  animateMaze = (walls) => {\r\n    for (let i = 0; i <= walls.length; i++) {\r\n      if (i === walls.length) {\r\n        setTimeout(() => {\r\n          this.ClearWalls();\r\n          let newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n          this.setState({\r\n            grid: newGrid,\r\n            constructingMaze: false\r\n          });\r\n        }, i * this.state.mazeSpeed);\r\n        return;\r\n      }\r\n      let wall = walls[i];\r\n      let node = this.state.grid[wall[0]][wall[1]];\r\n      setTimeout(() => {\r\n        //Walls\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-wall\";\r\n      }, i * this.state.mazeSpeed);\r\n    }\r\n  };\r\n\r\n  generateRandomMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = randomMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n  generateRecursiveDivisionMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n  generateVerticalMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = verticalMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateHorizontalMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = horizontalMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n\r\n\r\n  weightChangeHandler = (event) => {\r\n    this.setState({\r\n      weight: event.target.value\r\n    });\r\n  };\r\n\r\n  pointChangeHandler = () => {\r\n    if (this.notCorrect()) return; //To check if the provided value is suitable or not.\r\n\r\n    document.getElementById(\r\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n    ).className = \"node\";\r\n    document.getElementById(\r\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n    ).className = \"node\";\r\n\r\n    START_NODE_ROW = parseInt(document.getElementById(\"start_row\").value);\r\n    START_NODE_COL = parseInt(document.getElementById(\"start_col\").value);\r\n    FINISH_NODE_ROW = parseInt(document.getElementById(\"end_row\").value);\r\n    FINISH_NODE_COL = parseInt(document.getElementById(\"end_col\").value);\r\n\r\n    document.getElementById(\r\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n    ).className = \"node node-start\";\r\n    document.getElementById(\r\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n    ).className = \"node node-finish\";\r\n  };\r\n\r\n  notCorrect = () => {\r\n    if (\r\n      isNaN(parseInt(document.getElementById(\"start_row\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"start_col\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"end_row\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"end_col\").value))\r\n    )\r\n      return true;\r\n\r\n    if (\r\n      parseInt(document.getElementById(\"start_row\").value) > row_max_length ||\r\n      parseInt(document.getElementById(\"start_col\").value) > col_max_length\r\n    )\r\n      return true;\r\n    if (\r\n      parseInt(document.getElementById(\"start_row\").value) < 0 ||\r\n      parseInt(document.getElementById(\"start_col\").value) < 0\r\n    )\r\n      return true;\r\n\r\n    if (\r\n      parseInt(document.getElementById(\"end_row\").value) > row_max_length ||\r\n      parseInt(document.getElementById(\"end_col\").value) > col_max_length\r\n    )\r\n      return true;\r\n    if (\r\n      parseInt(document.getElementById(\"end_row\").value) < 0 ||\r\n      parseInt(document.getElementById(\"end_col\").value) < 0\r\n    )\r\n      return true;\r\n\r\n    return false;\r\n  };\r\n\r\n  toggleWeight = () => {\r\n    const temp = this.state.changeWeight;\r\n    this.setState({\r\n      changeWeight: !temp\r\n    });\r\n  };\r\n\r\n  render() {\r\n      const {\r\n        grid,\r\n        mouseIsPressed,\r\n        topMessage,\r\n        algo,\r\n      } = this.state;\r\n      let button_task = ( <\r\n        div className = \"rBtn\" >\r\n        <\r\n        div className = \"dropdown leftBtn\" >\r\n        <\r\n        p className = \"dropbtn\" > Select an algorithm < /p> <\r\n        div className = \"dropdown-content\" >\r\n        <\r\n        a onClick = {\r\n          () => this.setAlgoAstar()\r\n        } > A * Search < /a> <\r\n        a onClick = {\r\n          () => this.setAlgoDijkstra()\r\n        } > Dijkstra < /a><\r\n        a onClick = {\r\n          () => this.setAlgoGreedyBFS()\r\n        } > Greed BFS < /a>\r\n        <\r\n        a onClick = {\r\n          () => this.setAlgoBiGreedy()\r\n        } > Bidirectional Greed Search < /a> < /\r\n        div > <\r\n        /div> <\r\n        div className = \"rightBtn\" >\r\n        <\r\n        p className = \"buttonContainer\"\r\n        onClick = {\r\n          () => this.visualize()\r\n        } >\r\n        Start Visualizing!\r\n        <\r\n        /p> < /\r\n        div > <\r\n        /div>\r\n      );\r\n\r\n      if (topMessage === \"Shortest Path\") {\r\n        button_task = ( <\r\n          div\r\n\r\n          className = \"buttonContainer\"\r\n          style = {\r\n            {\r\n              width: \"10%\",\r\n              margin: \"auto\"\r\n            }\r\n          } >\r\n          <\r\n          h2 className = \"btn\"\r\n          href = \"#\"\r\n          onClick = {\r\n            () => window.location.reload(false)\r\n          } >\r\n          Reset <\r\n          /h2> < /\r\n          div >\r\n\r\n        );\r\n      } else if (topMessage === \"Calculating Shortest Path\") {\r\n        button_task = < h3 className = \"running\" > Running... < /h3>;\r\n      }\r\n\r\n      let changeWeightText = \"False\";\r\n\r\n      if (this.state.changeWeight) changeWeightText = \"True\";\r\n\r\n      let textBox = ( <\r\n        div className = \"textBox\" >\r\n        <\r\n        div >\r\n        <\r\n        div className = \"weightContainer\" >\r\n        <\r\n        label htmlFor = \"quantity\" > &emsp;&ensp; Set Weight < /label> <\r\n        input type = \"number\"\r\n        id = \"quantity\"\r\n        name = \"quantity\"\r\n        min = \"1\"\r\n        max = \"10\"\r\n        onChange = {\r\n          this.weightChangeHandler\r\n        }\r\n        defaultValue = \"1\" /\r\n        >\r\n        <\r\n        /div> <\r\n        div className = \"weightContainer\" >\r\n        <\r\n        label htmlFor = \"quantity\" > Toggle Weight < /label> <\r\n        button onClick = {\r\n          this.toggleWeight\r\n        } > {\r\n          changeWeightText\r\n        } < /button> < /\r\n        div > <\r\n        /div>\r\n\r\n        <\r\n        div >\r\n        <\r\n        div className = \"startPointContainer\" >\r\n        <\r\n        label htmlFor = \"point\" > &ensp;Start Point: < /label> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"start_row\"\r\n        min = \"0\"\r\n        max = {\r\n          row_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          START_NODE_ROW\r\n        } >\r\n        <\r\n        /input> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"start_col\"\r\n        min = \"0\"\r\n        max = {\r\n          col_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          START_NODE_COL\r\n        } >\r\n        <\r\n        /input>\r\n\r\n        <\r\n        /div> <\r\n        div className = \"endPointContainer\" >\r\n        <\r\n        label htmlFor = \"point\" > &ensp; End Point: < /label> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"end_row\"\r\n        min = \"0\"\r\n        max = {\r\n          row_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          FINISH_NODE_ROW\r\n        } >\r\n        <\r\n        /input> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"end_col\"\r\n        min = \"0\"\r\n        max = {\r\n          col_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          FINISH_NODE_COL\r\n        } >\r\n        <\r\n        /input> < /\r\n        div > <\r\n        /div>\r\n\r\n\r\n        <\r\n        div>\r\n        <\r\n        div className = \"dropdown mazePick\" >\r\n        <\r\n        p className = \"dropbtn\" > Generate Walls < /p> <\r\n        div className = \"dropdown-content\" >\r\n        <\r\n        a onClick = {\r\n          () => this.generateRandomMaze()\r\n        } > Random Maze < /a> <\r\n        a onClick = {\r\n          () => this.generateRecursiveDivisionMaze()\r\n        } > Recursive Division Maze < /a>\r\n        <\r\n        a onClick = {\r\n          () => this.generateVerticalMaze()\r\n        } > Vertical Devision Maze < /a> <\r\n        a onClick = {\r\n          () => this.generateHorizontalMaze()\r\n        } > Horizontal Devision Maze < /a>< /\r\n        div > <\r\n        /div> <\r\n        p className = \"buttonRand2\"\r\n        onClick = {\r\n          () => this.ClearWalls()\r\n        } >\r\n        Clear Walls <\r\n        /p> < /\r\n        div > <\r\n        div > {\r\n          button_task\r\n        } < /div> < /\r\n        div >\r\n      );\r\n\r\n      if (topMessage === \"Calculating Shortest Path\") {\r\n        textBox = ( <\r\n          div className = \"space\" > < /div>\r\n        );\r\n      } else if (topMessage === \"Shortest Path\") {\r\n        textBox = ( <\r\n          div > {\r\n            button_task\r\n          } <\r\n          div className = \"spaceL1\" > < /div> < /\r\n          div >\r\n        );\r\n      }\r\n      let heading;\r\n      if (algo === 0) {\r\n        heading = ( < h2 > Select a Pathfinding Algorithm! < /h2>)\r\n        }\r\n        else if (algo === 1) {\r\n          heading = ( < h2 > A * Search Pathfinding Algorithm < /h2>)\r\n          }\r\n          else if (algo === 2) {\r\n            heading = ( < h2 > Dijkstra Pathfinding Algorithm < /h2>)\r\n            }\r\n            else if (algo === 3) {\r\n              heading = ( < h2 >Greedy Best-first Search Algorithm < /h2>)\r\n              }\r\n              else if (algo === 4) {\r\n                heading = ( < h2 > Bidirectional Greedy Search Algorithm < /h2>)\r\n                }\r\n            else if (algo === -1) {\r\n              heading = ( < h2 > No Path Found! < /h2>)\r\n              }\r\n\r\n              return ( <\r\n                div className = \"pathfindingVisualizer\" >\r\n                <\r\n                div className = \"container\" >\r\n                <\r\n                div className = \"heading\" >\r\n                <\r\n                h1 > Pathfinding Visualizer < /h1> < /\r\n                div > <\r\n                div className = \"heading\" >\r\n                <\r\n                h3 > {\r\n                  heading\r\n                } < /h3> < /\r\n                div > {\r\n                  textBox\r\n                } <\r\n                /div>\r\n\r\n                <\r\n                div className = \"visualGridContainer\"\r\n                id = \"gridBody\" >\r\n                <\r\n                table className = \"grid\"\r\n                style = {\r\n                  {\r\n                    borderSpacing: \"0\"\r\n                  }\r\n                } >\r\n                <\r\n                tbody > {\r\n                  grid.map((row, rowIndex) => {\r\n                    return ( <\r\n                      tr key = {\r\n                        rowIndex\r\n                      } > {\r\n                        row.map((node, nodeIndex) => {\r\n                          const {\r\n                            isStart,\r\n                            isFinish,\r\n                            isWall,\r\n                            isWeight\r\n                          } = node; //Extracting from the node\r\n                          return ( <\r\n                            Node row = {\r\n                              rowIndex\r\n                            }\r\n                            col = {\r\n                              nodeIndex\r\n                            }\r\n                            key = {\r\n                              rowIndex + \"-\" + nodeIndex\r\n                            }\r\n                            isStart = {\r\n                              isStart\r\n                            }\r\n                            isFinish = {\r\n                              isFinish\r\n                            }\r\n                            isWall = {\r\n                              isWall\r\n                            }\r\n                            isWeight = {\r\n                              isWeight\r\n                            }\r\n                            mouseIsPressed = {\r\n                              mouseIsPressed\r\n                            }\r\n                            onMouseDown = {\r\n                              (row, col) =>\r\n                              this.handleMouseDown(row, col)\r\n                            }\r\n                            onMouseEnter = {\r\n                              (row, col) =>\r\n                              this.handleMouseEnter(row, col)\r\n                            }\r\n                            onMouseUp = {\r\n                              () => this.handleMouseUp()\r\n                            } >\r\n                            <\r\n                            /Node>\r\n                          );\r\n                        })\r\n                      } <\r\n                      /tr>\r\n                    );\r\n                  })\r\n                } <\r\n                /tbody> < /\r\n                table > <\r\n                /div> < /\r\n                div >\r\n              );\r\n            }\r\n          }\r\n\r\n          const getVisitedNodesInOrder = (\r\n  visitedNodesInOrderStart,\r\n  visitedNodesInOrderFinish\r\n) => {\r\n  let visitedNodesInOrder = [];\r\n  let n = Math.max(\r\n    visitedNodesInOrderStart.length,\r\n    visitedNodesInOrderFinish.length\r\n  );\r\n  for (let i = 0; i < n; i++) {\r\n    if (visitedNodesInOrderStart[i] !== undefined) {\r\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\r\n    }\r\n    if (visitedNodesInOrderFinish[i] !== undefined) {\r\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n};\r\n\r\n          const getInitialGrid = () => {\r\n            const grid = [];\r\n            for (let row = 0; row < row_max_length; row++) {\r\n              const currentRow = [];\r\n              for (let col = 0; col < col_max_length; col++) {\r\n                currentRow.push(createNode(col, row));\r\n              }\r\n              grid.push(currentRow);\r\n            }\r\n\r\n            return grid;\r\n          };\r\n\r\n          const createNode = (col, row) => {\r\n            return {\r\n              col,\r\n              row,\r\n              isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n              isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n              distance: Infinity,\r\n              isVisited: false,\r\n              isWall: false,\r\n              isWeight: false,\r\n              previousNode: null,\r\n              weight: 0,\r\n              g: 0,\r\n              f: 0,\r\n              h: 0,\r\n              neighbors: [],\r\n              previous: undefined,\r\n            };\r\n          };\r\n\r\n          const getNewGridWithMaze = (grid, walls) => {\r\n            let newGrid = grid.slice();\r\n            for (let wall of walls) {\r\n              let node = grid[wall[0]][wall[1]];\r\n              let newNode = {\r\n                ...node,\r\n                isWall: true,\r\n              };\r\n              newGrid[wall[0]][wall[1]] = newNode;\r\n            }\r\n            return newGrid;\r\n          };\r\n\r\n\r\n          const getNewGridWithWallToggled = (grid, row, col) => {\r\n            const newGrid = [...grid];\r\n            const node = newGrid[row][col];\r\n            const newNode = {\r\n              ...node, // copying other properties of the node\r\n              isWall: !node.isWall,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            return newGrid;\r\n          };\r\n\r\n          const getNewGridWithWeightToggled = (grid, row, col, weight) => {\r\n            const newGrid = [...grid];\r\n            const node = newGrid[row][col];\r\n            const newNode = {\r\n              ...node, // copying other properties of the node\r\n              isWeight: !node.isWeight,\r\n              weight: parseInt(weight),\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            return newGrid;\r\n          };\r\n","export function randomMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let walls = [];\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (\n        (row === startNode.row && col === startNode.col) ||\n        (row === finishNode.row && col === finishNode.col)\n      )\n        continue;\n      if (Math.random() < 0.33) {\n        walls.push([row, col]);\n      }\n    }\n  }\n  walls.sort(() => Math.random() - 0.5);\n  return walls;\n}\n","import \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer.jsx\";\n// import {Tutorial} from \"./PathfindingVisualizer/Tutorial/Tutorial.jsx\";\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\nreportWebVitals();\n"],"sourceRoot":""}