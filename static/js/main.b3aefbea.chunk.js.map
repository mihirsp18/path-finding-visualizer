{"version":3,"sources":["maze/recursiveDivision.js","maze/verticalMaze.js","maze/horizontalMaze.js","PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/Astar.js","algorithms/greedyBestFirstSearch.js","algorithms/bidirectionalGreedySearch.js","PathfindingVisualizer/PathfindingVisualizer.jsx","maze/randomMaze.js","App.js","reportWebVitals.js","index.js"],"names":["walls","Node","props","state","this","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","isWeight","extraClassName","id","className","draggable","Component","dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","weight","previousNode","getNeighbours","neighbours","neighbour","neighbourNotInUnvisitedNodes","manhattenDistance","finishNode","Math","abs","isNeighbour","closestNodeStart","closestNodeFinish","rowStart","colStart","rowFinish","colFinish","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","floor","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","verticalMaze","choice","getVerticalWalls","horizontalMaze","getHorizontalWalls","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","row_max_length","col_max_length","PathfindingVisualizer","animateMaze","setTimeout","ClearWalls","newGrid","getNewGridWithMaze","setState","constructingMaze","mazeSpeed","document","getElementById","weightChangeHandler","event","target","value","pointChangeHandler","notCorrect","parseInt","isNaN","toggleWeight","changeWeight","mouseIsPressed","status","distanceToBeTraveled","setStart","setEnd","algo","generatingMaze","speed","win","window","doc","docElem","documentElement","body","getElementsByTagName","x","innerWidth","clientWidth","y","innerHeight","clientHeight","round","console","log","getInitialGrid","getNewGridWithWeightToggled","getNewGridWithWallToggled","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animatePath","a","b","totalDistance","astar","getNodesInShortestPathOrderAstar","greedyBFS","getNodesInShortestPathOrderGreedyBFS","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesFinish","visitedNodesInOrderFinish","bidirectionalGreedySearch","isShortedPath","getNodesInShortestPathOrderBidirectionalGreedySearch","animateBidirectionalAlgorithm","visualizeAstar","visualizeDijkstra","visualizeGreedyBFS","visualizeBidirectionalGreedySearch","animateShortestPath","getVisitedNodesInOrder","undefined","timeTaken","randomMaze","button_task","onClick","setAlgoAstar","setAlgoDijkstra","setAlgoGreedyBFS","setAlgoBiGreedy","visualize","style","width","margin","href","location","reload","changeWeightText","heading","textBox","htmlFor","type","name","min","onChange","defaultValue","generateRandomMaze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","borderSpacing","map","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","n","currentRow","createNode","g","f","h","previous","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b3aefbea.chunk.js","sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}\n","let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const {\n      row,\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      isWeight,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isWeight\n      ? \"node-weight\"\n      : \"empty\";\n\n    return (\n      <td\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n        draggable= {isStart || isFinish}\n      ></td> // It is used to create the grid.\n    );\n  }\n}\n","export function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = []; \r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n\r\n    if (closestNode.isWall) continue;\r\n\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === endNode) return visitedNodesInOrder;\r\n\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n\r\n    neighbor.distance = node.distance + neighbor.weight + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function astar(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1 + closestNode.weight;\r\n      //f(n) = g(n) + h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderAstar(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function greedyBFS(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1 + closestNode.weight;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function bidirectionalGreedySearch(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodesStart = [];\r\n  let visitedNodesInOrderStart = [];\r\n  let unvisitedNodesFinish = [];\r\n  let visitedNodesInOrderFinish = [];\r\n  startNode.distance = 0;\r\n  finishNode.distance = 0;\r\n  unvisitedNodesStart.push(startNode);\r\n  unvisitedNodesFinish.push(finishNode);\r\n\r\n  while (\r\n    unvisitedNodesStart.length !== 0 &&\r\n    unvisitedNodesFinish.length !== 0\r\n  ) {\r\n    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNodeStart = unvisitedNodesStart.shift();\r\n    let closestNodeFinish = unvisitedNodesFinish.shift();\r\n\r\n    closestNodeStart.isVisited = true;\r\n    closestNodeFinish.isVisited = true;\r\n    visitedNodesInOrderStart.push(closestNodeStart);\r\n    visitedNodesInOrderFinish.push(closestNodeFinish);\r\n    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\r\n      return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n    }\r\n\r\n    //Start side search\r\n    let neighbours = getNeighbours(closestNodeStart, grid);\r\n    for (let neighbour of neighbours) {\r\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n        visitedNodesInOrderStart.push(closestNodeStart);\r\n        visitedNodesInOrderFinish.push(neighbour);\r\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n      }\r\n      let distance = closestNodeStart.distance + 1 + closestNodeStart.weight;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n        unvisitedNodesStart.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNodeStart;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNodeStart;\r\n      }\r\n    }\r\n\r\n    //Finish side search\r\n    neighbours = getNeighbours(closestNodeFinish, grid);\r\n    for (let neighbour of neighbours) {\r\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n        visitedNodesInOrderStart.push(closestNodeFinish);\r\n        visitedNodesInOrderStart.push(neighbour);\r\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n      }\r\n      let distance = closestNodeFinish.distance + 1 + closestNodeFinish.weight;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n        unvisitedNodesFinish.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNodeFinish;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNodeFinish;\r\n      }\r\n    }\r\n  }\r\n  return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\r\n}\r\n\r\nfunction isNeighbour(closestNodeStart, closestNodeFinish) {\r\n  let rowStart = closestNodeStart.row;\r\n  let colStart = closestNodeStart.col;\r\n  let rowFinish = closestNodeFinish.row;\r\n  let colFinish = closestNodeFinish.col;\r\n  if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\r\n  if (rowFinish === rowStart && colFinish === colStart + 1) return true;\r\n  if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\r\n  if (rowFinish === rowStart && colFinish === colStart - 1) return true;\r\n  return false;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction manhattenDistance(nodeA, nodeB) {\r\n  let x = Math.abs(nodeA.row - nodeB.row);\r\n  let y = Math.abs(nodeA.col - nodeB.col);\r\n  return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\r\n  nodeA,\r\n  nodeB\r\n) {\r\n  let distance= 0;\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = nodeB;\r\n  while (currentNode !== null) {\r\n    distance = distance + 1 + currentNode.weight;\r\n    nodesInShortestPathOrder.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  currentNode = nodeA;\r\n  while (currentNode !== null) {\r\n    distance = distance + 1 + currentNode.weight;\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1].distance = distance -1;\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, {\r\n  Component\r\n} from \"react\";\r\n\r\nimport Node from \"./Node/Node.jsx\";\r\n// import {showPopUp} from \"./Tutorial/Tutorial.jsx\";\r\n\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder\r\n} from \"../algorithms/dijkstra\";\r\nimport {\r\n  astar,\r\n  getNodesInShortestPathOrderAstar,\r\n} from \"../algorithms/Astar\";\r\nimport {\r\n  greedyBFS,\r\n  getNodesInShortestPathOrderGreedyBFS,\r\n} from \"../algorithms/greedyBestFirstSearch\";\r\nimport {\r\n  bidirectionalGreedySearch,\r\n  getNodesInShortestPathOrderBidirectionalGreedySearch,\r\n} from \"../algorithms/bidirectionalGreedySearch\";\r\nimport {\r\n  randomMaze\r\n} from \"../maze/randomMaze.js\";\r\nimport {\r\n  recursiveDivisionMaze\r\n} from \"../maze/recursiveDivision.js\";\r\nimport {\r\n  verticalMaze\r\n} from \"../maze/verticalMaze.js\";\r\nimport {\r\n  horizontalMaze\r\n} from \"../maze/horizontalMaze.js\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\n// Defining initial state of start and finish.\r\n\r\nlet row_max_length = 26;\r\nlet col_max_length = 46;\r\n\r\nlet START_NODE_ROW;\r\nlet START_NODE_COL;\r\nlet FINISH_NODE_ROW;\r\nlet FINISH_NODE_COL;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      status: \"Starting\",\r\n      weight: 1,\r\n      changeWeight: false,\r\n      distanceToBeTraveled: 0,\r\n      setStart: false,\r\n      setEnd: false,\r\n      algo: 0,\r\n      generatingMaze: false,\r\n      speed: 10,\r\n      mazeSpeed: 10,\r\n      constructingMaze: false,\r\n    };\r\n  }\r\n\r\n  // Creating grid\r\n  componentDidMount() {\r\n    var win = window,\r\n      doc = document,\r\n      docElem = doc.documentElement,\r\n      body = doc.getElementsByTagName('body')[0],\r\n      x = win.innerWidth || docElem.clientWidth || body.clientWidth,\r\n      y = win.innerHeight || docElem.clientHeight || body.clientHeight;\r\n    row_max_length = (y / 22) / 1.4;\r\n    col_max_length = x / 22;\r\n    START_NODE_ROW = Math.round(row_max_length / 2) - 2;\r\n    START_NODE_COL = 6;\r\n    FINISH_NODE_ROW = Math.round(row_max_length / 2) - 2;\r\n    FINISH_NODE_COL = Math.round(col_max_length - 6);\r\n    console.log(FINISH_NODE_COL);\r\n\r\n\r\n    const grid = getInitialGrid();\r\n    this.setState({\r\n      grid\r\n    });\r\n  }\r\n\r\n  ClearWalls() {\r\n    const grid = getInitialGrid();\r\n    this.setState({\r\n      grid\r\n    });\r\n  }\r\n\r\n\r\n  // On pressing the mouse down\r\n  handleMouseDown(row, col) {\r\n    if (this.state.status !== \"Starting\") return;\r\n    if (!(this.setStart || this.setEnd)) {\r\n      let newGrid = [];\r\n\r\n      if (this.state.changeWeight) {\r\n        newGrid = getNewGridWithWeightToggled(\r\n          this.state.grid,\r\n          row,\r\n          col,\r\n          this.state.weight\r\n        );\r\n      } else {\r\n        newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n      }\r\n\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true\r\n      });\r\n    } else if (this.setStart) {\r\n\r\n    } else if (this.setEnd) {\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // On entering the new node element.\r\n  handleMouseEnter(row, col) {\r\n    if (this.state.status !== \"Starting\") return;\r\n    if (this.setStart || this.setEnd) return;\r\n    if (!this.state.mouseIsPressed) return;\r\n\r\n    let newGrid = [];\r\n\r\n    if (this.state.changeWeight) {\r\n      newGrid = getNewGridWithWeightToggled(\r\n        this.state.grid,\r\n        row,\r\n        col,\r\n        this.state.weight\r\n      );\r\n    } else {\r\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    }\r\n\r\n    this.setState({\r\n      grid: newGrid,\r\n      mouseIsPressed: true\r\n    });\r\n  }\r\n\r\n  // When we release the mouse\r\n  handleMouseUp() {\r\n    if (this.state.status !== \"Starting\") return;\r\n    this.setState({\r\n      mouseIsPressed: false\r\n    });\r\n  }\r\n\r\n  setAlgoAstar() {\r\n    this.setState({\r\n      algo: 1\r\n    });\r\n  }\r\n  setAlgoDijkstra() {\r\n    this.setState({\r\n      algo: 2\r\n    });\r\n  }\r\n  setAlgoGreedyBFS() {\r\n    this.setState({\r\n      algo: 3\r\n    });\r\n  }\r\n  setAlgoBiGreedy() {\r\n    this.setState({\r\n      algo: 4\r\n    });\r\n  }\r\n\r\n\r\n\r\n  visualizeDijkstra() {\r\n    this.setState({\r\n      status: \"Calculating Shortest Path\"\r\n    });\r\n    const {\r\n      grid\r\n    } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeAstar() {\r\n    this.setState({\r\n      status: \"Calculating Shortest Path\"\r\n    });\r\n    const {\r\n      grid\r\n    } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(\r\n      finishNode\r\n    );\r\n    this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeGreedyBFS() {\r\n    this.setState({\r\n      status: \"Calculating Shortest Path\"\r\n    });\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderGreedyBFS(\r\n        finishNode\r\n      );\r\n      this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBidirectionalGreedySearch() {\r\n    this.setState({\r\n      status: \"Calculating Shortest Path\"\r\n    });\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = bidirectionalGreedySearch(\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    const visitedNodesInOrderStart = visitedNodesInOrder[0];\r\n    const visitedNodesInOrderFinish = visitedNodesInOrder[1];\r\n    const isShortedPath = visitedNodesInOrder[2];\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(\r\n      visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\r\n      visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\r\n    );\r\n    this.animateBidirectionalAlgorithm(\r\n      visitedNodesInOrderStart,\r\n      visitedNodesInOrderFinish,\r\n      nodesInShortestPathOrder,\r\n      isShortedPath\r\n    );\r\n}\r\n\r\n  visualize() {\r\n    if(!this.state.constructingMaze){\r\n      if (this.state.algo === 1) {\r\n        this.visualizeAstar();\r\n      } else if (this.state.algo === 2) {\r\n        this.visualizeDijkstra();\r\n      } else if (this.state.algo === 3) {\r\n        this.visualizeGreedyBFS();\r\n      } else if (this.state.algo === 4) {\r\n        this.visualizeBidirectionalGreedySearch();\r\n      }\r\n    }\r\n  }\r\n\r\n  animatePath(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      // When we reach the last element in visitedNodesInOrder.\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.setState({\r\n            status: \"Shortest Path\"\r\n          });\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, this.state.speed * i);\r\n        return;\r\n      }\r\n\r\n      if (i === visitedNodesInOrder.length - 1) continue;\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (node.isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visitedWeight\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, this.state.speed * i);\r\n    }\r\n  }\r\n  animateBidirectionalAlgorithm(\r\n  visitedNodesInOrderStart,\r\n  visitedNodesInOrderFinish,\r\n  nodesInShortestPathOrder,\r\n  isShortedPath\r\n) {\r\n  let len = Math.max(\r\n    visitedNodesInOrderStart.length,\r\n    visitedNodesInOrderFinish.length\r\n  );\r\n  for (let i = 1; i <= len; i++) {\r\n    let nodeA = visitedNodesInOrderStart[i];\r\n    let nodeB = visitedNodesInOrderFinish[i];\r\n    if (i === visitedNodesInOrderStart.length) {\r\n      setTimeout(() => {\r\n        let visitedNodesInOrder = getVisitedNodesInOrder(\r\n          visitedNodesInOrderStart,\r\n          visitedNodesInOrderFinish\r\n        );\r\n        if (isShortedPath) {\r\n          this.setState({\r\n            status: \"Shortest Path\"\r\n          });\r\n          this.animateShortestPath(\r\n            nodesInShortestPathOrder,\r\n            visitedNodesInOrder\r\n          );\r\n        }\r\n      }, i * this.state.speed);\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      //visited nodes\r\n      if (nodeA !== undefined)\r\n        document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className =\r\n          \"node node-visited\";\r\n      if (nodeB !== undefined)\r\n        document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className =\r\n          \"node node-visited\";\r\n    }, i * this.state.speed);\r\n  }\r\n}\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if (nodesInShortestPathOrder[i].isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path-weight\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path\";\r\n        }\r\n      }, this.state.speed * 5 * i);\r\n    }\r\n    let timeTaken =\r\n      nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1].distance;\r\n    this.setState({ distanceToBeTraveled: timeTaken,  algo: -1});\r\n  }\r\n\r\n  animateMaze = (walls) => {\r\n    for (let i = 0; i <= walls.length; i++) {\r\n      if (i === walls.length) {\r\n        setTimeout(() => {\r\n          this.ClearWalls();\r\n          let newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n          this.setState({\r\n            grid: newGrid,\r\n            constructingMaze: false\r\n          });\r\n        }, i * this.state.mazeSpeed);\r\n        return;\r\n      }\r\n      let wall = walls[i];\r\n      let node = this.state.grid[wall[0]][wall[1]];\r\n      setTimeout(() => {\r\n        //Walls\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-wall\";\r\n      }, i * this.state.mazeSpeed);\r\n    }\r\n  };\r\n\r\n  generateRandomMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = randomMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n  generateRecursiveDivisionMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n  generateVerticalMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = verticalMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateHorizontalMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = horizontalMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n\r\n\r\n  weightChangeHandler = (event) => {\r\n    this.setState({\r\n      weight: event.target.value\r\n    });\r\n  };\r\n\r\n  pointChangeHandler = () => {\r\n    if (this.notCorrect()) return; //To check if the provided value is suitable or not.\r\n\r\n    document.getElementById(\r\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n    ).className = \"node\";\r\n    document.getElementById(\r\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n    ).className = \"node\";\r\n\r\n    START_NODE_ROW = parseInt(document.getElementById(\"start_row\").value);\r\n    START_NODE_COL = parseInt(document.getElementById(\"start_col\").value);\r\n    FINISH_NODE_ROW = parseInt(document.getElementById(\"end_row\").value);\r\n    FINISH_NODE_COL = parseInt(document.getElementById(\"end_col\").value);\r\n\r\n    document.getElementById(\r\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n    ).className = \"node node-start\";\r\n    document.getElementById(\r\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n    ).className = \"node node-finish\";\r\n  };\r\n\r\n  notCorrect = () => {\r\n    if (\r\n      isNaN(parseInt(document.getElementById(\"start_row\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"start_col\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"end_row\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"end_col\").value))\r\n    )\r\n      return true;\r\n\r\n    if (\r\n      parseInt(document.getElementById(\"start_row\").value) > row_max_length ||\r\n      parseInt(document.getElementById(\"start_col\").value) > col_max_length\r\n    )\r\n      return true;\r\n    if (\r\n      parseInt(document.getElementById(\"start_row\").value) < 0 ||\r\n      parseInt(document.getElementById(\"start_col\").value) < 0\r\n    )\r\n      return true;\r\n\r\n    if (\r\n      parseInt(document.getElementById(\"end_row\").value) > row_max_length ||\r\n      parseInt(document.getElementById(\"end_col\").value) > col_max_length\r\n    )\r\n      return true;\r\n    if (\r\n      parseInt(document.getElementById(\"end_row\").value) < 0 ||\r\n      parseInt(document.getElementById(\"end_col\").value) < 0\r\n    )\r\n      return true;\r\n\r\n    return false;\r\n  };\r\n\r\n  toggleWeight = () => {\r\n    const temp = this.state.changeWeight;\r\n    this.setState({\r\n      changeWeight: !temp\r\n    });\r\n  };\r\n\r\n  render() {\r\n      const {\r\n        grid,\r\n        mouseIsPressed,\r\n        status,\r\n        distanceToBeTraveled,\r\n        algo,\r\n      } = this.state;\r\n      let button_task = ( <\r\n        div className = \"rBtn\" >\r\n        <\r\n        div className = \"dropdown leftBtn\" >\r\n        <\r\n        p className = \"dropbtn\" > Select an algorithm < /p> <\r\n        div className = \"dropdown-content\" >\r\n        <\r\n        a onClick = {\r\n          () => this.setAlgoAstar()\r\n        } > A * Search < /a> <\r\n        a onClick = {\r\n          () => this.setAlgoDijkstra()\r\n        } > Dijkstra < /a><\r\n        a onClick = {\r\n          () => this.setAlgoGreedyBFS()\r\n        } > Greed BFS < /a>\r\n        <\r\n        a onClick = {\r\n          () => this.setAlgoBiGreedy()\r\n        } > Bidirectional Greed Search < /a> < /\r\n        div > <\r\n        /div> <\r\n        div className = \"rightBtn\" >\r\n        <\r\n        p className = \"buttonContainer\"\r\n        onClick = {\r\n          () => this.visualize()\r\n        } >\r\n        Start Visualizing!\r\n        <\r\n        /p> < /\r\n        div > <\r\n        /div>\r\n      );\r\n\r\n      if (status === \"Shortest Path\") {\r\n        button_task = ( <\r\n          div\r\n\r\n          className = \"buttonContainer\"\r\n          style = {\r\n            {\r\n              width: \"10%\",\r\n              margin: \"auto\"\r\n            }\r\n          } >\r\n          <\r\n          h2 className = \"btn\"\r\n          href = \"#\"\r\n          onClick = {\r\n            () => window.location.reload(false)\r\n          } >\r\n          Reset <\r\n          /h2> < /\r\n          div >\r\n\r\n        );\r\n      } else if (status === \"Calculating Shortest Path\") {\r\n        button_task = < h3 className = \"running\" > Running... < /h3>;\r\n      }\r\n\r\n      let changeWeightText = \"False\";\r\n\r\n      if (this.state.changeWeight) changeWeightText = \"True\";\r\n\r\n      let textBox = ( <\r\n        div className = \"textBox\" >\r\n        <\r\n        div >\r\n        <\r\n        div className = \"weightContainer\" >\r\n        <\r\n        label htmlFor = \"quantity\" > &emsp;&ensp; Set Weight < /label> <\r\n        input type = \"number\"\r\n        id = \"quantity\"\r\n        name = \"quantity\"\r\n        min = \"1\"\r\n        max = \"10\"\r\n        onChange = {\r\n          this.weightChangeHandler\r\n        }\r\n        defaultValue = \"1\" /\r\n        >\r\n        <\r\n        /div> <\r\n        div className = \"weightContainer\" >\r\n        <\r\n        label htmlFor = \"quantity\" > Toggle Weight < /label> <\r\n        button onClick = {\r\n          this.toggleWeight\r\n        } > {\r\n          changeWeightText\r\n        } < /button> < /\r\n        div > <\r\n        /div>\r\n\r\n        <\r\n        div >\r\n        <\r\n        div className = \"startPointContainer\" >\r\n        <\r\n        label htmlFor = \"point\" > &ensp;Start Point: < /label> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"start_row\"\r\n        min = \"0\"\r\n        max = {\r\n          row_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          START_NODE_ROW\r\n        } >\r\n        <\r\n        /input> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"start_col\"\r\n        min = \"0\"\r\n        max = {\r\n          col_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          START_NODE_COL\r\n        } >\r\n        <\r\n        /input>\r\n\r\n        <\r\n        /div> <\r\n        div className = \"endPointContainer\" >\r\n        <\r\n        label htmlFor = \"point\" > &ensp; End Point: < /label> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"end_row\"\r\n        min = \"0\"\r\n        max = {\r\n          row_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          FINISH_NODE_ROW\r\n        } >\r\n        <\r\n        /input> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"end_col\"\r\n        min = \"0\"\r\n        max = {\r\n          col_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          FINISH_NODE_COL\r\n        } >\r\n        <\r\n        /input> < /\r\n        div > <\r\n        /div>\r\n\r\n\r\n        <\r\n        div>\r\n        <\r\n        div className = \"dropdown mazePick\" >\r\n        <\r\n        p className = \"dropbtn\" > Generate a Maze < /p> <\r\n        div className = \"dropdown-content\" >\r\n        <\r\n        a onClick = {\r\n          () => this.generateRandomMaze()\r\n        } > Random Maze < /a> <\r\n        a onClick = {\r\n          () => this.generateRecursiveDivisionMaze()\r\n        } > Recursive Division Maze < /a>\r\n        <\r\n        a onClick = {\r\n          () => this.generateVerticalMaze()\r\n        } > Vertical Devision Maze < /a> <\r\n        a onClick = {\r\n          () => this.generateHorizontalMaze()\r\n        } > Horizontal Devision Maze < /a>< /\r\n        div > <\r\n        /div> <\r\n        p className = \"buttonRand2\"\r\n        onClick = {\r\n          () => this.ClearWalls()\r\n        } >\r\n        Clear Walls <\r\n        /p> < /\r\n        div > <\r\n        div > {\r\n          button_task\r\n        } < /div> < /\r\n        div >\r\n      );\r\n\r\n      if (status === \"Calculating Shortest Path\") {\r\n        textBox = ( <\r\n          div className = \"space\" > < /div>\r\n        );\r\n      } else if (status === \"Shortest Path\") {\r\n        textBox = ( <\r\n          div > {\r\n            button_task\r\n          } <\r\n          div className = \"spaceL1\" > < /div> < /\r\n          div >\r\n        );\r\n      }\r\n      let heading;\r\n      if (algo === 0) {\r\n        heading = ( < h2 > Select a Pathfinding Algorithm! < /h2>)\r\n        }\r\n        else if (algo === 1) {\r\n          heading = ( < h2 > A * Search Pathfinding Algorithm < /h2>)\r\n          }\r\n          else if (algo === 2) {\r\n            heading = ( < h2 > Dijkstra Pathfinding Algorithm < /h2>)\r\n            }\r\n            else if (algo === 3) {\r\n              heading = ( < h2 >Greedy Best-first Search Algorithm < /h2>)\r\n              }\r\n              else if (algo === 4) {\r\n                heading = ( < h2 > Bidirectional Greedy Search Algorithm < /h2>)\r\n                }\r\n            else if (algo === -1) {\r\n              heading = ( < h2 > Distance travelled is: {distanceToBeTraveled} < /h2>)\r\n              }\r\n\r\n              return ( <\r\n                div className = \"pathfindingVisualizer\" >\r\n                <\r\n                div className = \"container\" >\r\n                <\r\n                div className = \"heading\" >\r\n                <\r\n                h1 > Pathfinding Visualizer < /h1> < /\r\n                div > <\r\n                div className = \"heading\" >\r\n                <\r\n                h3 > {\r\n                  heading\r\n                } < /h3> < /\r\n                div > {\r\n                  textBox\r\n                } <\r\n                /div>\r\n\r\n                <\r\n                div className = \"visualGridContainer\"\r\n                id = \"gridBody\" >\r\n                <\r\n                table className = \"grid\"\r\n                style = {\r\n                  {\r\n                    borderSpacing: \"0\"\r\n                  }\r\n                } >\r\n                <\r\n                tbody > {\r\n                  grid.map((row, rowIndex) => {\r\n                    return ( <\r\n                      tr key = {\r\n                        rowIndex\r\n                      } > {\r\n                        row.map((node, nodeIndex) => {\r\n                          const {\r\n                            isStart,\r\n                            isFinish,\r\n                            isWall,\r\n                            isWeight\r\n                          } = node; //Extracting from the node\r\n                          return ( <\r\n                            Node row = {\r\n                              rowIndex\r\n                            }\r\n                            col = {\r\n                              nodeIndex\r\n                            }\r\n                            key = {\r\n                              rowIndex + \"-\" + nodeIndex\r\n                            }\r\n                            isStart = {\r\n                              isStart\r\n                            }\r\n                            isFinish = {\r\n                              isFinish\r\n                            }\r\n                            isWall = {\r\n                              isWall\r\n                            }\r\n                            isWeight = {\r\n                              isWeight\r\n                            }\r\n                            mouseIsPressed = {\r\n                              mouseIsPressed\r\n                            }\r\n                            onMouseDown = {\r\n                              (row, col) =>\r\n                              this.handleMouseDown(row, col)\r\n                            }\r\n                            onMouseEnter = {\r\n                              (row, col) =>\r\n                              this.handleMouseEnter(row, col)\r\n                            }\r\n                            onMouseUp = {\r\n                              () => this.handleMouseUp()\r\n                            } >\r\n                            <\r\n                            /Node>\r\n                          );\r\n                        })\r\n                      } <\r\n                      /tr>\r\n                    );\r\n                  })\r\n                } <\r\n                /tbody> < /\r\n                table > <\r\n                /div> < /\r\n                div >\r\n              );\r\n            }\r\n          }\r\n\r\n          const getVisitedNodesInOrder = (\r\n  visitedNodesInOrderStart,\r\n  visitedNodesInOrderFinish\r\n) => {\r\n  let visitedNodesInOrder = [];\r\n  let n = Math.max(\r\n    visitedNodesInOrderStart.length,\r\n    visitedNodesInOrderFinish.length\r\n  );\r\n  for (let i = 0; i < n; i++) {\r\n    if (visitedNodesInOrderStart[i] !== undefined) {\r\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\r\n    }\r\n    if (visitedNodesInOrderFinish[i] !== undefined) {\r\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n};\r\n\r\n          const getInitialGrid = () => {\r\n            const grid = [];\r\n            for (let row = 0; row < row_max_length; row++) {\r\n              const currentRow = [];\r\n              for (let col = 0; col < col_max_length; col++) {\r\n                currentRow.push(createNode(col, row));\r\n              }\r\n              grid.push(currentRow);\r\n            }\r\n\r\n            return grid;\r\n          };\r\n\r\n          const createNode = (col, row) => {\r\n            return {\r\n              col,\r\n              row,\r\n              isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n              isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n              distance: Infinity,\r\n              totalDistance: Infinity,\r\n              isVisited: false,\r\n              isWall: false,\r\n              isWeight: false,\r\n              previousNode: null,\r\n              weight: 0,\r\n              g: 0,\r\n              f: 0,\r\n              h: 0,\r\n              neighbors: [],\r\n              previous: undefined,\r\n            };\r\n          };\r\n\r\n          const getNewGridWithMaze = (grid, walls) => {\r\n            let newGrid = grid.slice();\r\n            for (let wall of walls) {\r\n              let node = grid[wall[0]][wall[1]];\r\n              let newNode = {\r\n                ...node,\r\n                isWall: true,\r\n              };\r\n              newGrid[wall[0]][wall[1]] = newNode;\r\n            }\r\n            return newGrid;\r\n          };\r\n\r\n\r\n          const getNewGridWithWallToggled = (grid, row, col) => {\r\n            const newGrid = [...grid];\r\n            const node = newGrid[row][col];\r\n            const newNode = {\r\n              ...node, // copying other properties of the node\r\n              isWall: !node.isWall,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            return newGrid;\r\n          };\r\n\r\n          const getNewGridWithWeightToggled = (grid, row, col, weight) => {\r\n            const newGrid = [...grid];\r\n            const node = newGrid[row][col];\r\n            const newNode = {\r\n              ...node, // copying other properties of the node\r\n              isWeight: !node.isWeight,\r\n              weight: parseInt(weight),\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            return newGrid;\r\n          };\r\n","export function randomMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let walls = [];\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (\n        (row === startNode.row && col === startNode.col) ||\n        (row === finishNode.row && col === finishNode.col)\n      )\n        continue;\n      if (Math.random() < 0.33) {\n        walls.push([row, col]);\n      }\n    }\n  }\n  walls.sort(() => Math.random() - 0.5);\n  return walls;\n}\n","import \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer.jsx\";\n// import {Tutorial} from \"./PathfindingVisualizer/Tutorial/Tutorial.jsx\";\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\nreportWebVitals();\n"],"sourceRoot":""}