{"version":3,"sources":["maze/recursiveDivision.js","maze/verticalMaze.js","maze/horizontalMaze.js","PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/Astar.js","algorithms/greedyBestFirstSearch.js","algorithms/bidirectionalGreedySearch.js","PathfindingVisualizer/PathfindingVisualizer.jsx","maze/randomMaze.js","App.js","reportWebVitals.js","index.js"],"names":["walls","Node","props","state","this","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","isWeight","extraClassName","id","className","draggable","Component","dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","weight","previousNode","getNeighbours","neighbours","neighbour","neighbourNotInUnvisitedNodes","manhattenDistance","finishNode","Math","abs","isNeighbour","closestNodeStart","closestNodeFinish","rowStart","colStart","rowFinish","colFinish","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","floor","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","verticalMaze","choice","getVerticalWalls","horizontalMaze","getHorizontalWalls","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","row_max_length","col_max_length","PathfindingVisualizer","animateMaze","setTimeout","ClearWalls","newGrid","getNewGridWithMaze","setState","constructingMaze","mazeSpeed","document","getElementById","weightChangeHandler","event","target","value","pointChangeHandler","notCorrect","parseInt","isNaN","toggleWeight","changeWeight","mouseIsPressed","status","distanceToBeTraveled","setStart","setEnd","algo","generatingMaze","speed","x","clientWidth","y","clientHeight","ceil","getInitialGrid","getNewGridWithWeightToggled","getNewGridWithWallToggled","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animatePath","a","b","totalDistance","astar","getNodesInShortestPathOrderAstar","greedyBFS","getNodesInShortestPathOrderGreedyBFS","unvisitedNodesStart","visitedNodesInOrderStart","unvisitedNodesFinish","visitedNodesInOrderFinish","bidirectionalGreedySearch","isShortedPath","getNodesInShortestPathOrderBidirectionalGreedySearch","animateBidirectionalAlgorithm","visualizeAstar","visualizeDijkstra","visualizeGreedyBFS","visualizeBidirectionalGreedySearch","animateShortestPath","getVisitedNodesInOrder","console","log","undefined","timeTaken","randomMaze","button_task","onClick","setAlgoAstar","setAlgoDijkstra","setAlgoGreedyBFS","setAlgoBiGreedy","visualize","style","width","margin","href","window","location","reload","changeWeightText","heading","textBox","htmlFor","type","name","min","onChange","defaultValue","generateRandomMaze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","borderSpacing","map","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","class","n","currentRow","createNode","g","f","h","previous","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.56f0e7d3.chunk.js","sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}\n","let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const {\n      row,\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      isWeight,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isWeight\n      ? \"node-weight\"\n      : \"empty\";\n\n    return (\n      <td\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n        draggable= {isStart || isFinish}\n      ></td> // It is used to create the grid.\n    );\n  }\n}\n","export function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = []; \r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n\r\n    if (closestNode.isWall) continue;\r\n\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === endNode) return visitedNodesInOrder;\r\n\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n\r\n    neighbor.distance = node.distance + neighbor.weight + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function astar(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1 + closestNode.weight;\r\n      //f(n) = g(n) + h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + manhattenDistance(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderAstar(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function greedyBFS(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1 + closestNode.weight;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function bidirectionalGreedySearch(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodesStart = [];\r\n  let visitedNodesInOrderStart = [];\r\n  let unvisitedNodesFinish = [];\r\n  let visitedNodesInOrderFinish = [];\r\n  startNode.distance = 0;\r\n  finishNode.distance = 0;\r\n  unvisitedNodesStart.push(startNode);\r\n  unvisitedNodesFinish.push(finishNode);\r\n\r\n  while (\r\n    unvisitedNodesStart.length !== 0 &&\r\n    unvisitedNodesFinish.length !== 0\r\n  ) {\r\n    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNodeStart = unvisitedNodesStart.shift();\r\n    let closestNodeFinish = unvisitedNodesFinish.shift();\r\n\r\n    closestNodeStart.isVisited = true;\r\n    closestNodeFinish.isVisited = true;\r\n    visitedNodesInOrderStart.push(closestNodeStart);\r\n    visitedNodesInOrderFinish.push(closestNodeFinish);\r\n    if (isNeighbour(closestNodeStart, closestNodeFinish)) {\r\n      return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n    }\r\n\r\n    //Start side search\r\n    let neighbours = getNeighbours(closestNodeStart, grid);\r\n    for (let neighbour of neighbours) {\r\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n        visitedNodesInOrderStart.push(closestNodeStart);\r\n        visitedNodesInOrderFinish.push(neighbour);\r\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n      }\r\n      let distance = closestNodeStart.distance + 1 + closestNodeStart.weight;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n        unvisitedNodesStart.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNodeStart;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, finishNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNodeStart;\r\n      }\r\n    }\r\n\r\n    //Finish side search\r\n    neighbours = getNeighbours(closestNodeFinish, grid);\r\n    for (let neighbour of neighbours) {\r\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\r\n        visitedNodesInOrderStart.push(closestNodeFinish);\r\n        visitedNodesInOrderStart.push(neighbour);\r\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\r\n      }\r\n      let distance = closestNodeFinish.distance + 1 + closestNodeFinish.weight;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\r\n        unvisitedNodesFinish.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNodeFinish;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = manhattenDistance(neighbour, startNode)+neighbour.weight;\r\n        neighbour.previousNode = closestNodeFinish;\r\n      }\r\n    }\r\n  }\r\n  return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\r\n}\r\n\r\nfunction isNeighbour(closestNodeStart, closestNodeFinish) {\r\n  let rowStart = closestNodeStart.row;\r\n  let colStart = closestNodeStart.col;\r\n  let rowFinish = closestNodeFinish.row;\r\n  let colFinish = closestNodeFinish.col;\r\n  if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\r\n  if (rowFinish === rowStart && colFinish === colStart + 1) return true;\r\n  if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\r\n  if (rowFinish === rowStart && colFinish === colStart - 1) return true;\r\n  return false;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction manhattenDistance(nodeA, nodeB) {\r\n  let x = Math.abs(nodeA.row - nodeB.row);\r\n  let y = Math.abs(nodeA.col - nodeB.col);\r\n  return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBidirectionalGreedySearch(\r\n  nodeA,\r\n  nodeB\r\n) {\r\n  let distance= 0;\r\n  let nodesInShortestPathOrder = [];\r\n  let currentNode = nodeB;\r\n  while (currentNode !== null) {\r\n    distance = distance + 1 + currentNode.weight;\r\n    nodesInShortestPathOrder.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  currentNode = nodeA;\r\n  while (currentNode !== null) {\r\n    distance = distance + 1 + currentNode.weight;\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1].distance = distance -1;\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, {\r\n  Component\r\n} from \"react\";\r\n\r\nimport Node from \"./Node/Node.jsx\";\r\n// import {showPopUp} from \"./Tutorial/Tutorial.jsx\";\r\n\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder\r\n} from \"../algorithms/dijkstra\";\r\nimport {\r\n  astar,\r\n  getNodesInShortestPathOrderAstar,\r\n} from \"../algorithms/Astar\";\r\nimport {\r\n  greedyBFS,\r\n  getNodesInShortestPathOrderGreedyBFS,\r\n} from \"../algorithms/greedyBestFirstSearch\";\r\nimport {\r\n  bidirectionalGreedySearch,\r\n  getNodesInShortestPathOrderBidirectionalGreedySearch,\r\n} from \"../algorithms/bidirectionalGreedySearch\";\r\nimport {\r\n  randomMaze\r\n} from \"../maze/randomMaze.js\";\r\nimport {\r\n  recursiveDivisionMaze\r\n} from \"../maze/recursiveDivision.js\";\r\nimport {\r\n  verticalMaze\r\n} from \"../maze/verticalMaze.js\";\r\nimport {\r\n  horizontalMaze\r\n} from \"../maze/horizontalMaze.js\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\n// Defining initial state of start and finish.\r\n\r\nlet row_max_length = 26;\r\nlet col_max_length = 46;\r\n\r\nlet START_NODE_ROW;\r\nlet START_NODE_COL;\r\nlet FINISH_NODE_ROW;\r\nlet FINISH_NODE_COL;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      status: \"Starting\",\r\n      weight: 1,\r\n      changeWeight: false,\r\n      distanceToBeTraveled: 0,\r\n      setStart: false,\r\n      setEnd: false,\r\n      algo: 0,\r\n      generatingMaze: false,\r\n      speed: 12,\r\n      mazeSpeed: 10,\r\n      constructingMaze: false,\r\n    };\r\n  }\r\n\r\n  // Creating grid\r\n  componentDidMount() {\r\n    // var win = window,\r\n    // doc = document,\r\n    // docElem = doc.documentElement,\r\n    // body = doc.getElementsByTagName('body')[0],\r\n    //   x = win.innerWidth || docElem.clientWidth || body.clientWidth,\r\n    //   y = win.innerHeight || docElem.clientHeight || body.clientHeight;\r\n    let x = document.getElementById('gridBody').clientWidth - 4\r\n    let y = document.getElementById('gridBody').clientHeight - 4\r\n    // row_max_length = (y / 22) / 1.45;\r\n    row_max_length = Math.ceil(y / 24);\r\n    col_max_length = Math.ceil(x / 24);\r\n    START_NODE_ROW = Math.floor(row_max_length / 2) -2;\r\n    START_NODE_COL = 6;\r\n    FINISH_NODE_ROW = Math.floor(row_max_length / 2) -2;\r\n    FINISH_NODE_COL = Math.floor(col_max_length - 6);\r\n\r\n    const grid = getInitialGrid();\r\n    this.setState({\r\n      grid\r\n    });\r\n  }\r\n\r\n  ClearWalls() {\r\n    const grid = getInitialGrid();\r\n    this.setState({\r\n      grid\r\n    });\r\n  }\r\n\r\n\r\n  // On pressing the mouse down\r\n  handleMouseDown(row, col) {\r\n    if (this.state.status !== \"Starting\") return;\r\n    if (!(this.setStart || this.setEnd)) {\r\n      let newGrid = [];\r\n\r\n      if (this.state.changeWeight) {\r\n        newGrid = getNewGridWithWeightToggled(\r\n          this.state.grid,\r\n          row,\r\n          col,\r\n          this.state.weight\r\n        );\r\n      } else {\r\n        newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n      }\r\n\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true\r\n      });\r\n    } else if (this.setStart) {\r\n\r\n    } else if (this.setEnd) {\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // On entering the new node element.\r\n  handleMouseEnter(row, col) {\r\n    if (this.state.status !== \"Starting\") return;\r\n    if (this.setStart || this.setEnd) return;\r\n    if (!this.state.mouseIsPressed) return;\r\n\r\n    let newGrid = [];\r\n\r\n    if (this.state.changeWeight) {\r\n      newGrid = getNewGridWithWeightToggled(\r\n        this.state.grid,\r\n        row,\r\n        col,\r\n        this.state.weight\r\n      );\r\n    } else {\r\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    }\r\n\r\n    this.setState({\r\n      grid: newGrid,\r\n      mouseIsPressed: true\r\n    });\r\n  }\r\n\r\n  // When we release the mouse\r\n  handleMouseUp() {\r\n    if (this.state.status !== \"Starting\") return;\r\n    this.setState({\r\n      mouseIsPressed: false\r\n    });\r\n  }\r\n\r\n  setAlgoAstar() {\r\n    this.setState({\r\n      algo: 1\r\n    });\r\n  }\r\n  setAlgoDijkstra() {\r\n    this.setState({\r\n      algo: 2\r\n    });\r\n  }\r\n  setAlgoGreedyBFS() {\r\n    this.setState({\r\n      algo: 3\r\n    });\r\n  }\r\n  setAlgoBiGreedy() {\r\n    this.setState({\r\n      algo: 4\r\n    });\r\n  }\r\n\r\n\r\n\r\n  visualizeDijkstra() {\r\n    this.setState({\r\n      status: \"Calculating Shortest Path\"\r\n    });\r\n    const {\r\n      grid\r\n    } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeAstar() {\r\n    this.setState({\r\n      status: \"Calculating Shortest Path\"\r\n    });\r\n    const {\r\n      grid\r\n    } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(\r\n      finishNode\r\n    );\r\n    this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeGreedyBFS() {\r\n    this.setState({\r\n      status: \"Calculating Shortest Path\"\r\n    });\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderGreedyBFS(\r\n        finishNode\r\n      );\r\n      this.animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBidirectionalGreedySearch() {\r\n    this.setState({\r\n      status: \"Calculating Shortest Path\"\r\n    });\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = bidirectionalGreedySearch(\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    const visitedNodesInOrderStart = visitedNodesInOrder[0];\r\n    const visitedNodesInOrderFinish = visitedNodesInOrder[1];\r\n    const isShortedPath = visitedNodesInOrder[2];\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderBidirectionalGreedySearch(\r\n      visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\r\n      visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\r\n    );\r\n    this.animateBidirectionalAlgorithm(\r\n      visitedNodesInOrderStart,\r\n      visitedNodesInOrderFinish,\r\n      nodesInShortestPathOrder,\r\n      isShortedPath\r\n    );\r\n}\r\n\r\n  visualize() {\r\n    if(!this.state.constructingMaze){\r\n      if (this.state.algo === 1) {\r\n        this.visualizeAstar();\r\n      } else if (this.state.algo === 2) {\r\n        this.visualizeDijkstra();\r\n      } else if (this.state.algo === 3) {\r\n        this.visualizeGreedyBFS();\r\n      } else if (this.state.algo === 4) {\r\n        this.visualizeBidirectionalGreedySearch();\r\n      }\r\n    }\r\n  }\r\n\r\n  animatePath(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      // When we reach the last element in visitedNodesInOrder.\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.setState({\r\n            status: \"Shortest Path\"\r\n          });\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, this.state.speed * i);\r\n        return;\r\n      }\r\n\r\n      if (i === visitedNodesInOrder.length - 1) continue;\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (node.isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visitedWeight\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, this.state.speed * i);\r\n    }\r\n  }\r\n  animateBidirectionalAlgorithm(\r\n  visitedNodesInOrderStart,\r\n  visitedNodesInOrderFinish,\r\n  nodesInShortestPathOrder,\r\n  isShortedPath\r\n) {\r\n  let len = Math.max(\r\n    visitedNodesInOrderStart.length,\r\n    visitedNodesInOrderFinish.length\r\n  );\r\n  for (let i = 1; i <= len; i++) {\r\n    let nodeA = visitedNodesInOrderStart[i];\r\n    let nodeB = visitedNodesInOrderFinish[i];\r\n    if (i === visitedNodesInOrderStart.length) {\r\n      setTimeout(() => {\r\n        let visitedNodesInOrder = getVisitedNodesInOrder(\r\n          visitedNodesInOrderStart,\r\n          visitedNodesInOrderFinish\r\n        );\r\n        if (isShortedPath) {\r\n          this.setState({\r\n            status: \"Shortest Path\"\r\n          });\r\n          this.animateShortestPath(\r\n            nodesInShortestPathOrder,\r\n            visitedNodesInOrder\r\n          );\r\n        }\r\n        else {\r\n          this.setState({status: \"Shortest Path\", distanceToBeTraveled: Infinity,  algo: -1});\r\n        }\r\n      }, i * this.state.speed);\r\n      return;\r\n    }\r\n    console.log(\"sup\")\r\n    setTimeout(() => {\r\n      //visited nodes\r\n      if (nodeA !== undefined)\r\n        document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className =\r\n          \"node node-visited\";\r\n      if (nodeB !== undefined)\r\n        document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className =\r\n          \"node node-visited\";\r\n    }, i * this.state.speed);\r\n  }\r\n}\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if (nodesInShortestPathOrder[i].isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path-weight\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path\";\r\n        }\r\n      }, this.state.speed * 5 * i);\r\n    }\r\n    let timeTaken =\r\n      nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1].distance;\r\n    this.setState({ distanceToBeTraveled: timeTaken,  algo: -1});\r\n  }\r\n\r\n  animateMaze = (walls) => {\r\n    for (let i = 0; i <= walls.length; i++) {\r\n      if (i === walls.length) {\r\n        setTimeout(() => {\r\n          this.ClearWalls();\r\n          let newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n          this.setState({\r\n            grid: newGrid,\r\n            constructingMaze: false\r\n          });\r\n        }, i * this.state.mazeSpeed);\r\n        return;\r\n      }\r\n      let wall = walls[i];\r\n      let node = this.state.grid[wall[0]][wall[1]];\r\n      setTimeout(() => {\r\n        //Walls\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-wall\";\r\n      }, i * this.state.mazeSpeed);\r\n    }\r\n  };\r\n\r\n  generateRandomMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = randomMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed*3);\r\n  }\r\n  generateRecursiveDivisionMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n  generateVerticalMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = verticalMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateHorizontalMaze() {\r\n    if (this.state.constructingMaze) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      constructingMaze: true\r\n    });\r\n    setTimeout(() => {\r\n      const {\r\n        grid\r\n      } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = horizontalMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n\r\n\r\n  weightChangeHandler = (event) => {\r\n    this.setState({\r\n      weight: event.target.value\r\n    });\r\n  };\r\n\r\n  pointChangeHandler = () => {\r\n    if (this.notCorrect()) return; //To check if the provided value is suitable or not.\r\n\r\n    document.getElementById(\r\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n    ).className = \"node\";\r\n    document.getElementById(\r\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n    ).className = \"node\";\r\n\r\n    START_NODE_ROW = parseInt(document.getElementById(\"start_row\").value);\r\n    START_NODE_COL = parseInt(document.getElementById(\"start_col\").value);\r\n    FINISH_NODE_ROW = parseInt(document.getElementById(\"end_row\").value);\r\n    FINISH_NODE_COL = parseInt(document.getElementById(\"end_col\").value);\r\n\r\n    document.getElementById(\r\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n    ).className = \"node node-start\";\r\n    document.getElementById(\r\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n    ).className = \"node node-finish\";\r\n  };\r\n\r\n  notCorrect = () => {\r\n    if (\r\n      isNaN(parseInt(document.getElementById(\"start_row\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"start_col\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"end_row\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"end_col\").value))\r\n    )\r\n      return true;\r\n\r\n    if (\r\n      parseInt(document.getElementById(\"start_row\").value) > row_max_length ||\r\n      parseInt(document.getElementById(\"start_col\").value) > col_max_length\r\n    )\r\n      return true;\r\n    if (\r\n      parseInt(document.getElementById(\"start_row\").value) < 0 ||\r\n      parseInt(document.getElementById(\"start_col\").value) < 0\r\n    )\r\n      return true;\r\n\r\n    if (\r\n      parseInt(document.getElementById(\"end_row\").value) > row_max_length ||\r\n      parseInt(document.getElementById(\"end_col\").value) > col_max_length\r\n    )\r\n      return true;\r\n    if (\r\n      parseInt(document.getElementById(\"end_row\").value) < 0 ||\r\n      parseInt(document.getElementById(\"end_col\").value) < 0\r\n    )\r\n      return true;\r\n\r\n    return false;\r\n  };\r\n\r\n  toggleWeight = () => {\r\n    const temp = this.state.changeWeight;\r\n    this.setState({\r\n      changeWeight: !temp\r\n    });\r\n  };\r\n\r\n  render() {\r\n      const {\r\n        grid,\r\n        mouseIsPressed,\r\n        status,\r\n        distanceToBeTraveled,\r\n        algo,\r\n      } = this.state;\r\n      let button_task = ( <\r\n        div className = \"rBtn\" >\r\n        <\r\n        div className = \"dropdown leftBtn\" >\r\n        <\r\n        p className = \"dropbtn\" > Select an algorithm < /p> <\r\n        div className = \"dropdown-content\" >\r\n        <\r\n        a onClick = {\r\n          () => this.setAlgoAstar()\r\n        } > A * Search < /a> <\r\n        a onClick = {\r\n          () => this.setAlgoDijkstra()\r\n        } > Dijkstra < /a><\r\n        a onClick = {\r\n          () => this.setAlgoGreedyBFS()\r\n        } > Greed BFS < /a>\r\n        <\r\n        a onClick = {\r\n          () => this.setAlgoBiGreedy()\r\n        } > Bidirectional Greed Search < /a> < /\r\n        div > <\r\n        /div> <\r\n        div className = \"rightBtn\" >\r\n        <\r\n        p className = \"buttonContainer\"\r\n        onClick = {\r\n          () => this.visualize()\r\n        } >\r\n        Start Visualizing!\r\n        <\r\n        /p> < /\r\n        div > <\r\n        /div>\r\n      );\r\n\r\n      if (status === \"Shortest Path\") {\r\n        button_task = ( <\r\n          div\r\n\r\n          className = \"buttonContainer\"\r\n          style = {\r\n            {\r\n              width: \"10%\",\r\n              margin: \"auto\"\r\n            }\r\n          } >\r\n          <\r\n          h2 className = \"btn\"\r\n          href = \"#\"\r\n          onClick = {\r\n            () => window.location.reload(false)\r\n          } >\r\n          Reset <\r\n          /h2> < /\r\n          div >\r\n\r\n        );\r\n      } else if (status === \"Calculating Shortest Path\") {\r\n        button_task = < h3 className = \"running\" > Running... < /h3>;\r\n      }\r\n\r\n      let changeWeightText = \"False\";\r\n\r\n      if (this.state.changeWeight) changeWeightText = \"True\";\r\n\r\n      let textBox = ( <\r\n        div className = \"textBox\" >\r\n        <\r\n        div >\r\n        <\r\n        div className = \"weightContainer\" >\r\n        <\r\n        label htmlFor = \"quantity\" > &emsp;&ensp; Set Weight < /label> <\r\n        input type = \"number\"\r\n        id = \"quantity\"\r\n        name = \"quantity\"\r\n        min = \"1\"\r\n        max = \"10\"\r\n        onChange = {\r\n          this.weightChangeHandler\r\n        }\r\n        defaultValue = \"1\" /\r\n        >\r\n        <\r\n        /div> <\r\n        div className = \"weightContainer\" >\r\n        <\r\n        label htmlFor = \"quantity\" > Toggle Weight < /label> <\r\n        button onClick = {\r\n          this.toggleWeight\r\n        } > {\r\n          changeWeightText\r\n        } < /button> < /\r\n        div > <\r\n        /div>\r\n\r\n        <\r\n        div >\r\n        <\r\n        div className = \"startPointContainer\" >\r\n        <\r\n        label htmlFor = \"point\" > &ensp;Start Point: < /label> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"start_row\"\r\n        min = \"0\"\r\n        max = {\r\n          row_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          START_NODE_ROW\r\n        } >\r\n        <\r\n        /input> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"start_col\"\r\n        min = \"0\"\r\n        max = {\r\n          col_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          START_NODE_COL\r\n        } >\r\n        <\r\n        /input>\r\n\r\n        <\r\n        /div> <\r\n        div className = \"endPointContainer\" >\r\n        <\r\n        label htmlFor = \"point\" > &ensp; End Point: < /label> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"end_row\"\r\n        min = \"0\"\r\n        max = {\r\n          row_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          FINISH_NODE_ROW\r\n        } >\r\n        <\r\n        /input> <\r\n        input type = \"number\"\r\n        name = \"point\"\r\n        id = \"end_col\"\r\n        min = \"0\"\r\n        max = {\r\n          col_max_length - 1\r\n        }\r\n        onChange = {\r\n          this.pointChangeHandler\r\n        }\r\n        defaultValue = {\r\n          FINISH_NODE_COL\r\n        } >\r\n        <\r\n        /input> < /\r\n        div > <\r\n        /div>\r\n\r\n\r\n        <\r\n        div>\r\n        <\r\n        div className = \"dropdown mazePick\" >\r\n        <\r\n        p className = \"dropbtn\" > Generate a Maze < /p> <\r\n        div className = \"dropdown-content\" >\r\n        <\r\n        a onClick = {\r\n          () => this.generateRandomMaze()\r\n        } > Random Maze < /a> <\r\n        a onClick = {\r\n          () => this.generateRecursiveDivisionMaze()\r\n        } > Recursive Division Maze < /a>\r\n        <\r\n        a onClick = {\r\n          () => this.generateVerticalMaze()\r\n        } > Vertical Devision Maze < /a> <\r\n        a onClick = {\r\n          () => this.generateHorizontalMaze()\r\n        } > Horizontal Devision Maze < /a>< /\r\n        div > <\r\n        /div> <\r\n        p className = \"buttonRand2\"\r\n        onClick = {\r\n          () => this.ClearWalls()\r\n        } >\r\n        Clear Walls <\r\n        /p> < /\r\n        div > <\r\n        div > {\r\n          button_task\r\n        } < /div>\r\n        < / div >\r\n      );\r\n\r\n      if (status === \"Calculating Shortest Path\") {\r\n        textBox = ( <\r\n          div className = \"space\" > < /div>\r\n        );\r\n      } else if (status === \"Shortest Path\") {\r\n        textBox = ( <\r\n          div > {\r\n            button_task\r\n          } <\r\n          div className = \"spaceL1\" > < /div> < /\r\n          div >\r\n        );\r\n      }\r\n      let heading;\r\n      if (algo === 0) {\r\n        heading = ( < h2 > Select a Pathfinding Algorithm! < /h2>)\r\n        }\r\n        else if (algo === 1) {\r\n          heading = ( < h2 > A * Search Pathfinding Algorithm < /h2>)\r\n          }\r\n          else if (algo === 2) {\r\n            heading = ( < h2 > Dijkstra Pathfinding Algorithm < /h2>)\r\n            }\r\n            else if (algo === 3) {\r\n              heading = ( < h2 >Greedy Best-first Search Algorithm < /h2>)\r\n              }\r\n              else if (algo === 4) {\r\n                heading = ( < h2 > Bidirectional Greedy Search Algorithm < /h2>)\r\n                }\r\n            else if (algo === -1) {\r\n              heading = ( < h2 > Distance travelled is: {distanceToBeTraveled} < /h2>)\r\n              }\r\n\r\n              return (\r\n                <div className = \"pathfindingVisualizer\" >\r\n                <\r\n                div className = \"container\" >\r\n                <\r\n                div className = \"heading\" >\r\n                <\r\n                h1 > Pathfinding Visualizer < /h1> < /\r\n                div > <\r\n                div className = \"heading\" >\r\n                <\r\n                h3 > {\r\n                  heading\r\n                } < /h3> < /\r\n                div > {\r\n                  textBox\r\n                } <\r\n                /div>\r\n\r\n                <\r\n                div className = \"visualGridContainer\"\r\n                id = \"gridBody\" >\r\n                <\r\n                table className = \"grid\"\r\n                style = {\r\n                  {\r\n                    borderSpacing: \"0\"\r\n                  }\r\n                } >\r\n                <\r\n                tbody > {\r\n                  grid.map((row, rowIndex) => {\r\n                    return ( <\r\n                      tr key = {\r\n                        rowIndex\r\n                      } > {\r\n                        row.map((node, nodeIndex) => {\r\n                          const {\r\n                            isStart,\r\n                            isFinish,\r\n                            isWall,\r\n                            isWeight\r\n                          } = node; //Extracting from the node\r\n                          return ( <\r\n                            Node row = {\r\n                              rowIndex\r\n                            }\r\n                            col = {\r\n                              nodeIndex\r\n                            }\r\n                            key = {\r\n                              rowIndex + \"-\" + nodeIndex\r\n                            }\r\n                            isStart = {\r\n                              isStart\r\n                            }\r\n                            isFinish = {\r\n                              isFinish\r\n                            }\r\n                            isWall = {\r\n                              isWall\r\n                            }\r\n                            isWeight = {\r\n                              isWeight\r\n                            }\r\n                            mouseIsPressed = {\r\n                              mouseIsPressed\r\n                            }\r\n                            onMouseDown = {\r\n                              (row, col) =>\r\n                              this.handleMouseDown(row, col)\r\n                            }\r\n                            onMouseEnter = {\r\n                              (row, col) =>\r\n                              this.handleMouseEnter(row, col)\r\n                            }\r\n                            onMouseUp = {\r\n                              () => this.handleMouseUp()\r\n                            } >\r\n                            <\r\n                            /Node>\r\n                          );\r\n                        })\r\n                      } <\r\n                      /tr>\r\n                    );\r\n                  })\r\n                } <\r\n                /tbody> < /\r\n                table >\r\n                <footer>\r\n                  <p class=\"footer__author\">Check out the source code at: &ensp;<a href=\"https://github.com/mihirsp18/path-finding-visualizer\"><i class=\"fab fa-github\"></i></a></p>\r\n                </footer>\r\n                </div>\r\n                </div >\r\n              );\r\n            }\r\n          }\r\n\r\n          const getVisitedNodesInOrder = (\r\n  visitedNodesInOrderStart,\r\n  visitedNodesInOrderFinish\r\n) => {\r\n  let visitedNodesInOrder = [];\r\n  let n = Math.max(\r\n    visitedNodesInOrderStart.length,\r\n    visitedNodesInOrderFinish.length\r\n  );\r\n  for (let i = 0; i < n; i++) {\r\n    if (visitedNodesInOrderStart[i] !== undefined) {\r\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\r\n    }\r\n    if (visitedNodesInOrderFinish[i] !== undefined) {\r\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n};\r\n\r\n          const getInitialGrid = () => {\r\n            const grid = [];\r\n            for (let row = 0; row < row_max_length; row++) {\r\n              const currentRow = [];\r\n              for (let col = 0; col < col_max_length; col++) {\r\n                currentRow.push(createNode(col, row));\r\n              }\r\n              grid.push(currentRow);\r\n            }\r\n\r\n            return grid;\r\n          };\r\n\r\n          const createNode = (col, row) => {\r\n            return {\r\n              col,\r\n              row,\r\n              isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n              isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n              distance: Infinity,\r\n              totalDistance: Infinity,\r\n              isVisited: false,\r\n              isWall: false,\r\n              isWeight: false,\r\n              previousNode: null,\r\n              weight: 0,\r\n              g: 0,\r\n              f: 0,\r\n              h: 0,\r\n              neighbors: [],\r\n              previous: undefined,\r\n            };\r\n          };\r\n\r\n          const getNewGridWithMaze = (grid, walls) => {\r\n            let newGrid = grid.slice();\r\n            for (let wall of walls) {\r\n              let node = grid[wall[0]][wall[1]];\r\n              let newNode = {\r\n                ...node,\r\n                isWall: true,\r\n              };\r\n              newGrid[wall[0]][wall[1]] = newNode;\r\n            }\r\n            return newGrid;\r\n          };\r\n\r\n\r\n          const getNewGridWithWallToggled = (grid, row, col) => {\r\n            const newGrid = [...grid];\r\n            const node = newGrid[row][col];\r\n            const newNode = {\r\n              ...node, // copying other properties of the node\r\n              isWall: !node.isWall,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            return newGrid;\r\n          };\r\n\r\n          const getNewGridWithWeightToggled = (grid, row, col, weight) => {\r\n            const newGrid = [...grid];\r\n            const node = newGrid[row][col];\r\n            const newNode = {\r\n              ...node, // copying other properties of the node\r\n              isWeight: !node.isWeight,\r\n              weight: parseInt(weight),\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            return newGrid;\r\n          };\r\n","export function randomMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let walls = [];\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (\n        (row === startNode.row && col === startNode.col) ||\n        (row === finishNode.row && col === finishNode.col)\n      )\n        continue;\n      if (Math.random() < 0.33) {\n        walls.push([row, col]);\n      }\n    }\n  }\n  walls.sort(() => Math.random() - 0.5);\n  return walls;\n}\n","import \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer.jsx\";\n// import {Tutorial} from \"./PathfindingVisualizer/Tutorial/Tutorial.jsx\";\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\nreportWebVitals();\n"],"sourceRoot":""}